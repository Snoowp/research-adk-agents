
Yes, it's definitely possible to hook up your Google ADK-based agent to a GUI, and you can leverage FastAPI (or a similar web framework) to create the API endpoints that your GUI will interact with, much like you were doing with the LangGraph version.
Here's how the pieces would fit together:
ADK Agent Core Logic (Python):
This is the ROOT_AGENT and all its sub-agents (QueryGeneratorAgent, WebSearchInstanceAgent, ReflectionAgent, FinalAnswerAgent, etc.) as defined in the previous conceptual ADK Python code.
This core logic remains independent of the web framework.
FastAPI Backend (e.g., main.py or app.py):
You'll create FastAPI endpoints that the GUI will call.
One primary endpoint might be /research (or similar) which accepts a user's query.
Inside this endpoint, you will:
Instantiate your ADK Runner and SessionService.
Create or retrieve a user session.
Set the initial state for the session (e.g., the research_topic).
Invoke runner.run_async(...) with the user's query.
Process the events yielded by the runner.
Crucially for a GUI: Instead of just returning the final text, you'll want to stream updates back to the GUI to show progress. This is where Server-Sent Events (SSE) or WebSockets come in handy, just like in many modern chat applications.
GUI (Frontend - React/Vue/Angular/Static HTML+JS):
The GUI will make an HTTP request (e.g., POST to /research) to start the agent.
It will then listen for events streamed back from the FastAPI backend (e.g., via an SSE connection or WebSocket).
As events arrive, the GUI updates to show:
Intermediate steps (e.g., "Generating search queries...", "Performing web research for 'X'...", "Reflecting on findings...").
The final answer.
Sources/citations.
FastAPI Backend Example with Streaming for GUI:
Let's adapt the handle_research_request concept to stream updates using FastAPI's StreamingResponse with Server-Sent Events (SSE).
# --- main.py (FastAPI app with ADK agent integration) ---
import os
import asyncio
import json
from typing import AsyncGenerator, Dict, Any
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse, HTMLResponse # For serving frontend index.html
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import pathlib # For frontend serving

# Assuming your ADK agent (ROOT_AGENT, AGENT_CONFIG, etc.) is in a module called 'adk_research_agent'
from adk_research_agent import ROOT_AGENT, AGENT_CONFIG # Import your ADK ROOT_AGENT

from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService # Or your persistent choice
from google.genai import types as genai_types

app = FastAPI()

# --- Frontend Serving (similar to your original app.py) ---
def create_frontend_router(build_dir="../frontend/dist"):
    build_path = pathlib.Path(__file__).parent.parent / build_dir # Adjust path as needed
    static_files_path = build_path / "assets"

    if not build_path.is_dir() or not (build_path / "index.html").is_file():
        print(f"WARN: Frontend build directory not found or incomplete at {build_path}.")
        # Dummy router if build isn't ready
        from starlette.routing import Route
        async def dummy_frontend(request):
            return HTMLResponse("Frontend not built.", status_code=503)
        return Route("/{path:path}", endpoint=dummy_frontend)

    react_app = FastAPI(openapi_url="")
    react_app.mount("/assets", StaticFiles(directory=static_files_path), name="static_assets")

    @react_app.get("/{path:path}")
    async def handle_catch_all(request: Request, path: str):
        fp = build_path / path
        if not fp.exists() or not fp.is_file():
            fp = build_path / "index.html"
        return HTMLResponse(fp.read_text(), media_type="text/html")

    return react_app

app.mount("/app", create_frontend_router(), name="frontend")


# --- ADK Agent Interaction ---
class ResearchQuery(BaseModel):
    query: str
    session_id: Optional[str] = None # Allow client to manage session continuity

# Global or managed session service and runner instances
# For simplicity, global here. In production, manage these more robustly.
SESSION_SERVICE = InMemorySessionService()
ADK_RUNNER = Runner(
    agent=ROOT_AGENT,
    app_name="adk_research_fastapi_app",
    session_service=SESSION_SERVICE
)

async def research_event_generator(user_query: str, user_id: str, session_id: str) -> AsyncGenerator[str, None]:
    """
    Runs the ADK agent and yields JSON-formatted Server-Sent Events.
    """
    initial_state = {
        "research_topic": user_query,
        "research_loop_count": 0,
        # Add other initial configs if your agents expect them in state
    }
    try:
        # Ensure session exists or create it
        try:
            session = await SESSION_SERVICE.get_session(app_name=ADK_RUNNER.app_name, user_id=user_id, session_id=session_id)
            # If session exists, you might want to merge or reset parts of its state
            # For simplicity, we'll use initial_state if creating, or let existing state persist
            if session:
                 # Update research_topic for existing session, keep other state
                session.state["research_topic"] = user_query
                await SESSION_SERVICE.update_session(session) # Persist change
            else:
                raise KeyError # Force creation
        except KeyError:
            session = await SESSION_SERVICE.create_session(
                app_name=ADK_RUNNER.app_name,
                user_id=user_id,
                session_id=session_id,
                state=initial_state
            )
    except Exception as e:
        error_event = {"type": "error", "message": f"Session creation/retrieval failed: {str(e)}"}
        yield f"data: {json.dumps(error_event)}\n\n"
        return

    # Format the input message for the first agent in the sequence
    # This depends on how your first ADK agent (QueryGeneratorAgent) expects its input.
    # Let's assume it takes the raw query and number_of_initial_queries from AGENT_CONFIG
    formatted_input_for_generator = f"Research Topic: {user_query}\nNumber of Queries: {AGENT_CONFIG['number_of_initial_queries']}"
    initial_message_content = genai_types.Content(parts=[genai_types.Part(text=formatted_input_for_generator)])

    try:
        async for event in ADK_RUNNER.run_async(session_id=session.id, user_id=user_id, new_message=initial_message_content):
            event_data: Dict[str, Any] = {"type": "agent_event", "author": event.author}
            if event.content and event.content.parts:
                # Assuming text content for simplicity
                event_data["message"] = event.content.parts[0].text
            elif event.actions and event.actions.escalate:
                 event_data["message"] = f"Agent escalated: {event.error_message or 'No specific message.'}"
            else:
                event_data["message"] = "Action event or no text content."

            if event.is_final_response() and event.author == ROOT_AGENT.sub_agents[-1].name: # Assuming FinalAnswerAgent is last
                event_data["is_final"] = True
                # Retrieve final sources from state if your FinalAnswerAgent's callback saves them
                updated_session = await SESSION_SERVICE.get_session(app_name=ADK_RUNNER.app_name, user_id=user_id, session_id=session.id)
                event_data["sources"] = updated_session.state.get("final_answer_sources_used", [])
            else:
                event_data["is_final"] = False

            yield f"data: {json.dumps(event_data)}\n\n"

            if event_data.get("is_final"):
                break # Stop streaming after the final answer from the designated agent
    except Exception as e:
        error_event = {"type": "error", "message": f"Agent execution error: {str(e)}"}
        yield f"data: {json.dumps(error_event)}\n\n"
    finally:
        # Optional: cleanup or final status event
        yield f"data: {json.dumps({'type': 'stream_end'})}\n\n"


@app.post("/api/research-stream")
async def stream_research(payload: ResearchQuery, request: Request):
    user_id = "default_user" # Replace with actual user management if needed
    session_id = payload.session_id or f"session_{os.urandom(8).hex()}" # Generate if not provided

    # Check if client disconnected
    async def check_disconnect():
        while True:
            if await request.is_disconnected():
                print(f"Client for session {session_id} disconnected.")
                # Here you could signal the ADK_RUNNER to interrupt the ongoing agent run if ADK supports it.
                # ADK's LiveRequestQueue has a close() method, but interrupting a run_async mid-flight
                # is more complex and might not be directly supported without custom agent logic
                # to check for an interruption signal in its state.
                break
            await asyncio.sleep(0.1)

    # Start disconnect checker in background
    # disconnect_task = asyncio.create_task(check_disconnect()) # Needs careful handling with ADK agent interruption

    event_stream = research_event_generator(payload.query, user_id, session_id)
    
    # The StreamingResponse will keep the connection open and send data as it's yielded.
    # The `disconnect_task` needs to be cancelled when the stream finishes or errors.
    # For simplicity, we're not fully implementing interruption here.
    return StreamingResponse(event_stream, media_type="text/event-stream")

if __name__ == "__main__":
    # Ensure your adk_research_agent.py is in the same directory or Python path
    # And that AGENT_CONFIG is accessible
    uvicorn.run(app, host="0.0.0.0", port=8000)
Use code with caution.
Python
Frontend (Conceptual JavaScript for SSE):
// In your frontend JavaScript (e.g., React component, vanilla JS)
let eventSource = null;

async function startResearch(query, sessionId) {
    if (eventSource) {
        eventSource.close();
    }

    // Clear previous messages display
    const messagesDiv = document.getElementById('messages'); // Assuming you have this
    messagesDiv.innerHTML = '';

    eventSource = new EventSource(`/api/research-stream`, {
        method: 'POST', // EventSource doesn't directly support POST, so this is a conceptual issue.
                        // Standard EventSource is GET only.
                        // For POST with streaming, you'd typically use fetch API with ReadableStream
                        // or WebSockets.

        // ---- CORRECTED APPROACH for POST + Streaming (using fetch) ----
        // This is more complex than simple EventSource.
        // For true SSE with POST, the initial POST might return a stream ID,
        // and then a GET request with EventSource uses that ID.
        // Or, use fetch API directly to handle the stream.
    });

    // Let's assume for simplicity we can make a POST and get an SSE stream back
    // (some frameworks/proxies might allow this, or use fetch API for streaming POST body)

    // If using fetch for streaming response:
    try {
        const response = await fetch('/api/research-stream', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ query: query, session_id: sessionId }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            appendMessage(`Error: ${errorData.message || response.statusText}`, 'error');
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                appendMessage("Stream finished.", "info");
                break;
            }
            const chunk = decoder.decode(value, { stream: true });
            // SSE chunks are "data: {...}\n\n"
            const lines = chunk.split('\n\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const eventData = JSON.parse(line.substring(6));
                        handleStreamEvent(eventData);
                    } catch (e) {
                        console.error("Failed to parse SSE event:", line, e);
                    }
                }
            }
        }
    } catch (error) {
        console.error('Streaming research failed:', error);
        appendMessage(`Connection error: ${error.message}`, 'error');
    }
}

function handleStreamEvent(eventData) {
    const messagesDiv = document.getElementById('messages'); // Your display area
    let p = document.createElement('p');

    if (eventData.type === "agent_event") {
        p.innerHTML = `<strong>${eventData.author}:</strong> ${eventData.message}`;
        if (eventData.is_final) {
            p.innerHTML += "<br/><strong>--- FINAL ANSWER ---</strong>";
            if (eventData.sources && eventData.sources.length > 0) {
                let sourcesHtml = "<br/><strong>Sources:</strong><ul>";
                eventData.sources.forEach(src => {
                    sourcesHtml += `<li><a href="${src.value}" target="_blank">${src.label || src.value}</a></li>`;
                });
                sourcesHtml += "</ul>";
                p.innerHTML += sourcesHtml;
            }
        }
    } else if (eventData.type === "error") {
        p.textContent = `ERROR: ${eventData.message}`;
        p.style.color = "red";
    } else if (eventData.type === "stream_end") {
        p.textContent = "Agent processing complete.";
        p.style.fontStyle = "italic";
    }
    messagesDiv.appendChild(p);
    messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll
}

function appendMessage(text, type = 'info') { // Helper for non-event messages
    const messagesDiv = document.getElementById('messages');
    let p = document.createElement('p');
    p.textContent = text;
    if (type === 'error') p.style.color = 'red';
    messagesDiv.appendChild(p);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// --- Example of how to call it from your GUI ---
// const researchButton = document.getElementById('researchButton');
// const queryInput = document.getElementById('queryInput');
// let currentSessionId = null; // Manage session ID for conversation continuity

// researchButton.addEventListener('click', () => {
//     const query = queryInput.value;
//     if (!currentSessionId) {
//         currentSessionId = `session_${Math.random().toString(36).substring(2, 10)}`;
//     }
//     if (query) {
//         startResearch(query, currentSessionId);
//     }
// });
Use code with caution.
JavaScript
Key Considerations for GUI Integration:
Streaming: For a good UX, streaming intermediate updates is vital. SSE is simpler for server-to-client streaming. WebSockets are more powerful for bidirectional communication but add complexity. The FastAPI example uses SSE.
Correcting SSE with POST: Standard EventSource in browsers is GET only. To stream a response from a POST request, you typically:
Make the POST request with fetch.
The server's response body should be a stream.
You read from this stream using response.body.getReader() and decode the SSE formatted chunks manually, as shown in the corrected JavaScript.
Session Management: The GUI needs to send a session_id back to the server if it wants to continue an existing conversation. The server can then retrieve the state for that session.
Error Handling: Both the backend and frontend need robust error handling.
Agent Interruption: If the user closes the GUI or wants to stop the agent, sending an interruption signal from the FastAPI backend to the ADK Runner can be complex. ADK's LiveRequestQueue has a close() method which might signal interruption for agents designed for live/streaming input, but interrupting a standard run_async flow mid-way requires the agent itself to periodically check for an interruption flag in its state or a more advanced ADK feature if available.
ADK Runner and SessionService Lifecycle: In a production FastAPI app, you wouldn't create new Runner and SessionService instances on every request. They should be initialized once when the FastAPI app starts and managed (e.g., as singletons or using a dependency injection system).
Complexity of ADK Agent: The ADK agent, especially with parallel steps and loops, will generate many internal events. You'll need to decide which of these are meaningful to display on the GUI. The event.author can help filter.
In summary: Yes, you can connect your ADK agent to a GUI using FastAPI. The main change from your LangGraph setup will be how the agent logic is structured (using ADK's agent types) and how you stream events from the ADK Runner through FastAPI to the frontend. The SSE approach with fetch on the client-side is a common way to achieve this for POST-initiated streaming.